<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=2973bc063cc18ebb9d2bcb1f87d4129c77979e88">


    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Play with Tezos - Tezos_crypto module and Ed25519 elliptic curve | Random notes</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Play with Tezos - Tezos_crypto module and Ed25519 elliptic curve" />
<meta name="author" content="Danny Willems" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Let’s play today with some submodules of Tezos_crypto. First, compile Tezos and install utop git clone https://gitlab.com/tezos/tezos/ /tmp/tezos-play cd /tmp/tezos-play make build-deps eval $(opam config env) make make build-dev-deps opam install utop" />
<meta property="og:description" content="Let’s play today with some submodules of Tezos_crypto. First, compile Tezos and install utop git clone https://gitlab.com/tezos/tezos/ /tmp/tezos-play cd /tmp/tezos-play make build-deps eval $(opam config env) make make build-dev-deps opam install utop" />
<link rel="canonical" href="http://localhost:4000/2019/01/14/play-with-tezos-crypto-ed25519.html" />
<meta property="og:url" content="http://localhost:4000/2019/01/14/play-with-tezos-crypto-ed25519.html" />
<meta property="og:site_name" content="Random notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-14T00:00:00+01:00" />
<script type="application/ld+json">
{"description":"Let’s play today with some submodules of Tezos_crypto. First, compile Tezos and install utop git clone https://gitlab.com/tezos/tezos/ /tmp/tezos-play cd /tmp/tezos-play make build-deps eval $(opam config env) make make build-dev-deps opam install utop","@type":"BlogPosting","headline":"Play with Tezos - Tezos_crypto module and Ed25519 elliptic curve","dateModified":"2019-01-14T00:00:00+01:00","datePublished":"2019-01-14T00:00:00+01:00","url":"http://localhost:4000/2019/01/14/play-with-tezos-crypto-ed25519.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/01/14/play-with-tezos-crypto-ed25519.html"},"author":{"@type":"Person","name":"Danny Willems"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <h1>Random notes</h1>
        <h2>Random notes on FP, blockchain/DLT, crypto currency, cryptography, (computational) algebra, (computational) number theory, logic, type system, maybe quantum computing</h2>

        <section id="downloads">
          
          <a href="https://github.com/dannywillems/dannywillems.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>14 January 2019</small>
<h1>Play with Tezos - Tezos_crypto module and Ed25519 elliptic curve</h1>

<p class="view">by Danny Willems</p>

<p>Let’s play today with some submodules of <a href="https://gitlab.com/tezos/tezos/tree/master/src/lib_crypto">Tezos_crypto</a>.
First, compile Tezos and install <code class="highlighter-rouge">utop</code></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://gitlab.com/tezos/tezos/ /tmp/tezos-play
<span class="nb">cd</span> /tmp/tezos-play
make build-deps
<span class="nb">eval</span> <span class="k">$(</span>opam config env<span class="k">)</span>
make
make build-dev-deps
opam install utop
</code></pre></div></div>

<p>Now, move to the directory <code class="highlighter-rouge">src/lib_crypto</code> and run <code class="highlighter-rouge">dune utop</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>src/lib_crypto
dune utop
</code></pre></div></div>

<p>For the moment, Tezos does support 3 elliptic curves: Ed25519, P256 and
secp256k1. Today, we are going to focus on Ed25519, implemented using a binding
to HaCl (see <a href="https://gitlab.com/tezos/tezos/blob/master/src/lib_crypto/ed25519.ml#L48">open
HaCl</a>
statement at the top of the file).</p>

<p>Tezos uses the base58 prefixes <code class="highlighter-rouge">edsk</code> for the Ed25519 private keys and <code class="highlighter-rouge">edpk</code> for
the public keys to encode the keys. You can check the prefixes
<a href="https://gitlab.com/tezos/tezos/blob/master/src/lib_crypto/base58.ml#L347">here</a>.
The relevant OCaml module in <code class="highlighter-rouge">lib_crypto</code> to play with Ed25519 is
<a href="https://gitlab.com/tezos/tezos/blob/master/src/lib_crypto/ed25519.ml">ed25519.ml</a>.</p>

<p>Let’s take one Ed25519 private key, encoded in base58 using the Tezos prefix:
<code class="highlighter-rouge">edsk31vznjHSSpGExDMHYASz45VZqXN4DPxvsa4hAyY8dHM28cZzp6</code>. That’s the one
generated for you when you create a <a href="https://tezos.gitlab.io/user/sandbox.html">Tezos sandbox
environment</a>.</p>

<p>The top module does also provide a function to generate a keypair:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">pkh</span><span class="o">,</span> <span class="n">pk</span><span class="o">,</span> <span class="n">sk</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">generate_key</span> <span class="bp">()</span><span class="p">;;</span>
<span class="c">(* val pkh : Tezos_crypto.Ed25519.Public_key_hash.t = &lt;abstr&gt; *)</span>
<span class="c">(* val pk : Tezos_crypto.Ed25519.Public_key.t = &lt;abstr&gt; *)</span>
<span class="c">(* val sk : Tezos_crypto.Ed25519.Secret_key.t = &lt;abstr&gt; *)</span>
</code></pre></div></div>

<p>The pubkeyhash (pkh) is the corresponding tz1 address. See below.</p>

<p>The module we are interested in is <code class="highlighter-rouge">Tezos_crypto__Ed25519</code>. It does provide the
submodules <code class="highlighter-rouge">Secret_key</code> and <code class="highlighter-rouge">Public_key</code> to respectively manage secret and
public keys. The top module and the type <code class="highlighter-rouge">Tezos_crypto.Ed25519.t</code> is used to
represent a signature:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ed_sk</span> <span class="o">=</span> <span class="nn">Tezos_crypto__Ed25519</span><span class="p">.</span><span class="nn">Secret_key</span><span class="p">.</span><span class="n">of_b58check_exn</span>
  <span class="s2">"edsk31vznjHSSpGExDMHYASz45VZqXN4DPxvsa4hAyY8dHM28cZzp6"</span><span class="p">;;</span>
<span class="c">(* val ed_sk : Tezos_crypto.Ed25519.Secret_key.t = &lt;abstr&gt; *)</span>
<span class="k">let</span> <span class="n">ed_pk</span> <span class="o">=</span> <span class="nn">Tezos_crypto__Ed25519</span><span class="p">.</span><span class="nn">Secret_key</span><span class="p">.</span><span class="n">to_public_key</span> <span class="n">ed_sk</span><span class="p">;;</span>
<span class="c">(* val ed_pk : Tezos_crypto.Ed25519.Public_key.t = &lt;abstr&gt; *)</span>
<span class="k">let</span> <span class="n">base58_ed_pk</span> <span class="o">=</span> <span class="nn">Tezos_crypto__Ed25519</span><span class="p">.</span><span class="nn">Public_key</span><span class="p">.</span><span class="n">to_b58check</span> <span class="n">ed_pk</span><span class="p">;;</span>
<span class="c">(* val base58_ed_pk : string =
  "edpkuSLWfVU1Vq7Jg9FucPyKmma6otcMHac9zG4oU1KMHSTBpJuGQ2" *)</span>
</code></pre></div></div>

<p>Notice the secret key and the public key have different types, respectively
<code class="highlighter-rouge">Tezos_crypto.Ed25519.Secret_key.t</code> and <code class="highlighter-rouge">Tezos_crypto.Ed25519.Public_key.t</code>.
Even if intrinsically, secret and public keys are bytes, the type system avoids
using a secret key in place of a public key and vice versa in the different
functions.</p>

<p>Let’s now sign and verify a message with these keys using <code class="highlighter-rouge">Tezos_crypto.Ed25519.sign</code> and <code class="highlighter-rouge">Tezos_crypto.Ed25519.check</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">signature</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">sign</span> <span class="n">ed_sk</span> <span class="p">(</span><span class="nn">Bytes</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"Hello, World!"</span><span class="p">);;</span>
<span class="c">(* val signature : Tezos_crypto.Ed25519.t = &lt;abstr&gt; *)</span>
<span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">check</span> <span class="n">ed_pk</span> <span class="n">signature</span> <span class="p">(</span><span class="nn">Bytes</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"Hello, World!"</span><span class="p">);;</span>
<span class="c">(* - : bool = true *)</span>
</code></pre></div></div>

<p>The message can be any document, and these functions may be used to verify Alice signs the document. We also expect the <code class="highlighter-rouge">check</code> function to return <code class="highlighter-rouge">false</code> if Eve signs the message:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* We generate a random secret key (which would be Eve's) to sign the message *)</span>
<span class="k">let</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">eve_ed_sk</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">generate_key</span> <span class="bp">()</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">signature</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">sign</span> <span class="n">eve_ed_sk</span> <span class="p">(</span><span class="nn">Bytes</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"Hello, World!"</span><span class="p">);;</span>
<span class="c">(* and Bob checks the signature using Alice public key, ed_pk in our case, which is invalid *)</span>
<span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">check</span> <span class="n">ed_pk</span> <span class="n">signature</span> <span class="p">(</span><span class="nn">Bytes</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"Hello, World!"</span><span class="p">);;</span>
<span class="c">(* - : bool = false *)</span>

</code></pre></div></div>
<p>It is worth to mention, thanks to the type system, we cannot use a public key to sign a message:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">signature</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">sign</span> <span class="n">ed_pk</span> <span class="p">(</span><span class="nn">Bytes</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"Hello, World!"</span><span class="p">);;</span>
<span class="c">(* Error: This expression has type Tezos_crypto.Ed25519.Public_key.t
       but an expression was expected of type Tezos_crypto.Ed25519.Secret_key.t
*)</span>
</code></pre></div></div>
<p>and we cannot use a secret key to verify a signature:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="n">check</span> <span class="n">ed_sk</span> <span class="n">signature</span><span class="p">;;</span>
<span class="c">(* Error: This expression has type Tezos_crypto.Ed25519.Secret_key.t
       but an expression was expected of type Tezos_crypto.Ed25519.Public_key.t
*)</span>
</code></pre></div></div>

<p>To get the Tezos address related to this keypair, we use the module
<code class="highlighter-rouge">Tezos_crypto.Ed25519.Public_key_hash</code>. Let’s remind a Tezos address is simply a
hash of the public key, base58 encoded with a specific prefix.
The public key hash for a Ed25519 keypair starts with <code class="highlighter-rouge">tz1</code>. To get the hash of
the public key as bytes (as a <code class="highlighter-rouge">Bytes.t</code> type in Tezos codebase), we use the function <code class="highlighter-rouge">Tezos_crypto.Ed25519.Public_key.hash</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">decoded_pkh</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="nn">Public_key</span><span class="p">.</span><span class="n">hash</span> <span class="n">pk</span><span class="p">;;</span>
<span class="c">(* val decoded_pkh : Tezos_crypto.Ed25519.Public_key_hash.t = &lt;abstr&gt; *)</span>
</code></pre></div></div>

<p>Let’s finish with the base58 encoded version of the public key hash:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b58_encoded_pkh</span> <span class="o">=</span> <span class="nn">Tezos_crypto</span><span class="p">.</span><span class="nn">Ed25519</span><span class="p">.</span><span class="nn">Public_key_hash</span><span class="p">.</span><span class="n">to_b58check</span> <span class="n">decoded_pkh</span><span class="p">;;</span>
<span class="c">(* val b58_encoded_pkh : string = "tz1cp2CRXtX3dDWTtqbTocCTmMdKv69AuWNb" *)</span>
</code></pre></div></div>



  <small>tags: <em>OCaml</em> - <em>Tezos</em> - <em>Cryptography</em> - <em>ED25519</em> - <em>Elliptic Curve</em> - <em>EC</em></small>


      </section>
    </div>

    
  </body>
</html>


